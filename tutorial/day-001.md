下面给你一套 **Day 1（ROS2 Topic 发布/订阅）**可以直接照做的“从 0 到跑起来 + 能讲清楚”的步骤。默认你已经装好 ROS2（Ubuntu 22.04=Humble / Ubuntu 24.04=Jazzy 都适用，命令基本一致）。

---

## 0) 准备：打开一个“干净”的 ROS2 终端环境

每次新开终端，先做这两件事（先别嫌烦，后面你会感谢它）：

```bash
# 1) source ROS2
source /opt/ros/$ROS_DISTRO/setup.bash

# 2) 可选：确认 distro
echo $ROS_DISTRO
```

建议把 `source /opt/ros/$ROS_DISTRO/setup.bash` 写进 `~/.bashrc`（以后每个新终端自动生效）。

---

## 1) 先用官方 Demo 跑起来：Python pub/sub（不写代码也能先理解）

### 1.1 跑 subscriber（终端 A）

```bash
ros2 run demo_nodes_py listener
```

你会看到它在等待消息。

### 1.2 跑 publisher（终端 B）

```bash
ros2 run demo_nodes_py talker
```

此时 listener 会持续打印收到的字符串。

> 你已经完成了：**一个节点发布 topic，另一个节点订阅同一个 topic**。

---

## 2) 用 CLI “看懂”Topic（列表、类型、内容、频率）

下面这些是 Day 1 的核心技能：**不用写代码也能调试 ROS2 通信**。

### 2.1 看当前有哪些 topic

（在任意一个新终端，记得 source 过）

```bash
ros2 topic list
```

你会看到类似：

* `/chatter`
* `/rosout`
* 其他系统/日志 topic

### 2.2 看某个 topic 的 message type

```bash
ros2 topic info /chatter
```

会告诉你类型，比如：

* `std_msgs/msg/String`
* 还有发布者/订阅者数量

### 2.3 实时查看 topic 内容（相当于“抓包”）

```bash
ros2 topic echo /chatter
```

会不停打印消息。

### 2.4 看发布频率（Hz）

```bash
ros2 topic hz /chatter
```

会显示平均频率、抖动等。

### 2.5 只看一次（适合脚本/验证）

```bash
ros2 topic echo /chatter --once
```

### 2.6 “手动发布一条消息”（不写代码）

```bash
ros2 topic pub --once /chatter std_msgs/msg/String "{data: 'hello from cli'}"
```

> 这一步非常关键：你会意识到 **topic 是“消息通道”**，任何节点只要遵守同样的 message type，就能发布/订阅。

---

## 3) 你要能讲出来：Topic 是什么，为什么适合高频/异步

你可以用这段话复述（建议写进 notes）：

* **Node（节点）**：ROS2 里运行的进程/组件，负责做事（传感器驱动、控制器、导航、UI…）。
* **Topic**：一种 **发布/订阅** 的通信通道；适合 **连续流式数据**（传感器、状态更新、里程计、心跳等）。
* **Message Type**：topic 上传输数据的结构定义（比如 `std_msgs/msg/String`、`geometry_msgs/msg/Twist`）。
* **Publisher / Subscriber**：发布者往 topic 写消息；订阅者从 topic 读消息。两者解耦：彼此不知道对方是谁。
* **为什么适合高频/异步**：

  * 发布者只管“不断发”，订阅者按自己节奏“不断收”
  * 组件解耦：可以随时增加/删除订阅者，不影响发布者逻辑
  * 支持多对多：一个发布者多个订阅者，多个发布者也可（但要注意语义和冲突）
* **QoS（先知道存在）**：决定“可靠性/延迟/队列深度”等传输策略；尤其对高频传感器和不稳定网络很重要。

---

## 4) 输出要求：写你自己的最小 package（改官方 demo 的“小参数”）

目标：你要交付一个“最小可运行”的包：**至少改一个参数**（发布频率或消息内容）。

下面给你一个最稳的路线：自己建一个 Python package，写一个 talker + listener，然后改频率/内容。

### 4.1 建 workspace

```bash
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws
```

### 4.2 创建 Python package

```bash
cd ~/ros2_ws/src
ros2 pkg create day1_topics --build-type ament_python --dependencies rclpy std_msgs
```

现在目录大概是：

```
~/ros2_ws/src/day1_topics/
  package.xml
  setup.py
  setup.cfg
  resource/day1_topics
  day1_topics/
    __init__.py
```

### 4.3 写发布者节点（talker）

创建文件：

```bash
nano ~/ros2_ws/src/day1_topics/day1_topics/talker.py
```

粘贴以下内容：

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimpleTalker(Node):
    def __init__(self):
        super().__init__('simple_talker')

        # 参数：发布频率 Hz、消息前缀
        self.declare_parameter('hz', 2.0)
        self.declare_parameter('prefix', 'hello')

        self.publisher_ = self.create_publisher(String, 'chatter', 10)

        self.count = 0
        self._reset_timer()

        self.get_logger().info("SimpleTalker started. Publishing on topic 'chatter'.")

    def _reset_timer(self):
        hz = float(self.get_parameter('hz').value)
        period = 1.0 / hz if hz > 0 else 0.5
        if hasattr(self, 'timer'):
            self.timer.cancel()
        self.timer = self.create_timer(period, self._on_timer)

    def _on_timer(self):
        prefix = str(self.get_parameter('prefix').value)
        msg = String()
        msg.data = f"{prefix} #{self.count}"
        self.publisher_.publish(msg)
        self.get_logger().info(f"Published: {msg.data}")
        self.count += 1

def main():
    rclpy.init()
    node = SimpleTalker()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### 4.4 写订阅者节点（listener）

```bash
nano ~/ros2_ws/src/day1_topics/day1_topics/listener.py
```

粘贴：

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimpleListener(Node):
    def __init__(self):
        super().__init__('simple_listener')
        self.subscription = self.create_subscription(
            String,
            'chatter',
            self._callback,
            10
        )
        self.get_logger().info("SimpleListener started. Subscribing to topic 'chatter'.")

    def _callback(self, msg: String):
        self.get_logger().info(f"Received: {msg.data}")

def main():
    rclpy.init()
    node = SimpleListener()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### 4.5 注册 console scripts（让 `ros2 run` 能找到它）

编辑 `setup.py`：

```bash
nano ~/ros2_ws/src/day1_topics/setup.py
```

找到 `entry_points`，改成类似这样（保留原有结构，重点是加两行）：

```python
entry_points={
    'console_scripts': [
        'talker = day1_topics.talker:main',
        'listener = day1_topics.listener:main',
    ],
},
```

### 4.6 构建 & source

```bash
cd ~/ros2_ws
colcon build
source install/setup.bash
```

### 4.7 运行你的最小 demo

终端 A：

```bash
source ~/ros2_ws/install/setup.bash
ros2 run day1_topics listener
```

终端 B：

```bash
source ~/ros2_ws/install/setup.bash
ros2 run day1_topics talker
```

你应该看到 listener 收到你发布的内容。

---

## 5) “改一个小参数”的要求：改发布频率 / 改消息内容（用参数实现）

### 5.1 改发布频率（比如 10Hz）

```bash
ros2 run day1_topics talker --ros-args -p hz:=10.0
```

然后用 CLI 验证：

```bash
ros2 topic hz /chatter
```

### 5.2 改消息内容前缀

```bash
ros2 run day1_topics talker --ros-args -p prefix:="day1"
```

然后：

```bash
ros2 topic echo /chatter
```

你会看到消息变成：

* `day1 #0`
* `day1 #1`
* …

> 这就是 Day 1 的“最小 package + 改一个参数”闭环。

---

## 6) （可选加分）跑一个 C++ 版本（最快路径：直接跑官方 demo）

如果你只是想“跑起来加分”，不用自己建包：

终端 A：

```bash
ros2 run demo_nodes_cpp listener
```

终端 B：

```bash
ros2 run demo_nodes_cpp talker
```

一样能用 `ros2 topic ...` 去检查 `/chatter`。

---

## 7) 你要提交的输出：`notes/day1_topics.md`

在你的学习仓库（或随便一个目录）创建：

```bash
mkdir -p notes
nano notes/day1_topics.md
```

给你一份可以直接贴进去的模板（你按自己实际输出替换少量内容）：

````md
# Day 1 — ROS2 Topic (Pub/Sub) 基础

## 今日目标
理解 ROS2 最核心通信模型：Topic 发布/订阅，并能用 CLI 调试。

## 核心概念
- Node：ROS2 里的运行实体（进程/组件），负责执行功能。
- Topic：发布/订阅的消息通道，适合连续流式数据（传感器、状态更新）。
- Message Type：topic 上传输数据的结构定义（例：std_msgs/msg/String）。
- Publisher/Subscriber：发布者写入 topic；订阅者读取 topic。两者解耦、多对多。
- QoS：控制可靠性/延迟/队列策略（今天只知道它存在）。

## 为什么 Topic 适合高频/异步
- 发布端与订阅端解耦：彼此不需要知道对方存在。
- 多订阅者天然支持：调试/记录/多个模块复用同一数据流。
- 异步：发布者按频率发，订阅者按回调处理。

## CLI 操作记录
### 查看 topic 列表
```bash
ros2 topic list
````

### 查看 topic 类型和 pub/sub 数量

```bash
ros2 topic info /chatter
```

### 查看消息内容

```bash
ros2 topic echo /chatter
```

### 查看频率

```bash
ros2 topic hz /chatter
```

### 手动发布一条消息

```bash
ros2 topic pub --once /chatter std_msgs/msg/String "{data: 'hello from cli'}"
```

## 运行官方 demo

* Python:

  * `ros2 run demo_nodes_py talker`
  * `ros2 run demo_nodes_py listener`
* (可选) C++:

  * `ros2 run demo_nodes_cpp talker`
  * `ros2 run demo_nodes_cpp listener`

## 我自己的最小 package：day1_topics

Workspace: `~/ros2_ws`

### 构建

```bash
cd ~/ros2_ws
colcon build
source install/setup.bash
```

### 运行

终端 A:

```bash
ros2 run day1_topics listener
```

终端 B:

```bash
ros2 run day1_topics talker
```

### 我做的修改（至少一个）

* 支持参数 `hz` 控制发布频率
* 支持参数 `prefix` 控制消息内容前缀

示例：

```bash
ros2 run day1_topics talker --ros-args -p hz:=10.0 -p prefix:="day1"
```

```

---

如果你愿意，我也可以直接按你机器情况（Humble 还是 Jazzy、你是否已装 ros-dev-tools/colcon）把“可能会踩坑的依赖安装命令 + 常见报错对照表”一并补上，但上面这套在大多数已装好 ROS2 的环境里是可以 **直接执行跑通** 的。
```
